	The file UdaConnectDependenciesMonolith.png shows the architecture in its original state as a monolith. What I noticed from this diagram is that it could be split into 3 separate microservice to serve 3 separate entities: locations, connections, and persons. I decided to do just that and used the strangler pattern to spin off the entities 1 by 1 into their own microservice. The file architecture_design.png shows the architecture after it has been split into microservices.
	The persons_api microservice gets its Persons entities from the Kafka topic called “persons”. The data from the persons.csv file is ingested into Kafka after the pod is created. Moreover, this microservice creates a gRPC message for each Person entity. 
	The connections_api microservice uses a complex query to obtain “all Person who have been within a given distance of a given Person within a date range.” Part of this query involves acquiring all available persons objects. This is accomplished via a REST call to the persons_api microservice.
	The locations_api microservice gets its Locations entities from the Postgres DB.
